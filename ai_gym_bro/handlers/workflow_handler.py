"""Handles the multi-step conversation workflow for plan generation."""

from loguru import logger
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)

from ai_gym_bro.services import openai_service  # Use the alias
from ai_gym_bro.handlers.common import (
    ASK_AGE,
    ASK_HEIGHT,
    ASK_WEIGHT,
    ASK_EXPERIENCE,
    ASK_BENCH,
    ASK_INJURIES,
    SELECT_GOAL,
    GENERATING_PLAN,
    AWAITING_REFINEMENT_CHOICE,
    AWAITING_REFINEMENT_INPUT,  # Updated states
    GOAL_OPTIONS,
    HYPERTROPHY,
    POWERLIFTING,
    ASK_QUESTION_CALLBACK,
    MODIFY_PLAN_CALLBACK,  # Refinement callback data
    USER_DATA_AGE,
    USER_DATA_HEIGHT,
    USER_DATA_WEIGHT,
    USER_DATA_EXPERIENCE,
    USER_DATA_BENCH,
    USER_DATA_INJURIES,
    USER_DATA_GOAL,
    USER_DATA_PLAN,
    USER_DATA_HISTORY,
    USER_DATA_REFINEMENT_TYPE,  # New user data key
)
from ai_gym_bro.handlers.start_handler import start, cancel  # Import start for entry point, cancel for fallback

# --- Helper Functions ---


async def _ask_next_question(update: Update, context: ContextTypes.DEFAULT_TYPE, question: str, next_state: int) -> int:
    """Helper to ask a question and return the next state."""
    # Check if update.message exists (for text input) or update.callback_query (for button clicks)
    if update.message:
        await update.message.reply_text(question)
    elif update.callback_query:
        # If coming from a button, edit the message to ask the next question
        await update.callback_query.edit_message_text(question)
    else:
        logger.warning("Update type not handled in _ask_next_question")
        # Fallback if update type is unexpected
        if update.effective_chat:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=question)

    return next_state


async def _store_and_advance(
    update: Update, context: ContextTypes.DEFAULT_TYPE, key: str, question: str, next_state: int
) -> int:
    """Helper to store user text input and ask the next question."""
    user_input = update.message.text
    context.user_data[key] = user_input
    logger.debug(f"User {update.effective_user.id}: Stored {key} = {user_input}")
    return await _ask_next_question(update, context, question, next_state)


# --- State Handler Functions ---


async def received_age(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores age and asks for height."""
    return await _store_and_advance(
        update, context, USER_DATA_AGE, "–ü–æ–Ω—è—Ç–Ω–æ. –ö–∞–∫–æ–π —É –≤–∞—Å —Ä–æ—Å—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–º –∏–ª–∏ —Ñ—É—Ç—ã/–¥—é–π–º—ã)?", ASK_HEIGHT
    )


async def received_height(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores height and asks for weight."""
    return await _store_and_advance(
        update, context, USER_DATA_HEIGHT, "–°–ø–∞—Å–∏–±–æ. –ê –≤–∞—à —Ç–µ–∫—É—â–∏–π –≤–µ—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–≥ –∏–ª–∏ —Ñ—É–Ω—Ç—ã)?", ASK_WEIGHT
    )


async def received_weight(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores weight and asks for experience."""
    return await _store_and_advance(
        update,
        context,
        USER_DATA_WEIGHT,
        "–ö–∞–∫–æ–π —É –≤–∞—Å —É—Ä–æ–≤–µ–Ω—å –æ–ø—ã—Ç–∞ –≤ —Å–∏–ª–æ–≤—ã—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞—á–∏–Ω–∞—é—â–∏–π, —Å—Ä–µ–¥–Ω–∏–π, –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π)?",
        ASK_EXPERIENCE,
    )


async def received_experience(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores experience and asks for bench max."""
    return await _store_and_advance(
        update,
        context,
        USER_DATA_EXPERIENCE,
        "–ö–∞–∫–æ–π —É –≤–∞—Å —Ç–µ–∫—É—â–∏–π –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã–π –º–∞–∫—Å–∏–º—É–º –≤ 1 –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–∏ (1–ü–ú) –∏–ª–∏ –ª—É—á—à–∏–π –ø–æ–¥—Ö–æ–¥ –≤ –ñ–∏–º–µ –ª–µ–∂–∞?",
        ASK_BENCH,
    )


async def received_bench(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores bench max and asks for injuries."""
    return await _store_and_advance(
        update,
        context,
        USER_DATA_BENCH,
        "–ï—Å—Ç—å –ª–∏ —É –≤–∞—Å –∫–∞–∫–∏–µ-–ª–∏–±–æ —Ç–µ–∫—É—â–∏–µ —Ç—Ä–∞–≤–º—ã –∏–ª–∏ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, –æ –∫–æ—Ç–æ—Ä—ã—Ö –º–Ω–µ —Å–ª–µ–¥—É–µ—Ç –∑–Ω–∞—Ç—å? (–ù–∞–ø–∏—à–∏—Ç–µ '–ù–µ—Ç', –µ—Å–ª–∏ –Ω–µ—Ç)",
        ASK_INJURIES,
    )


async def received_injuries(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores injuries and asks for training goal."""
    user_input = update.message.text
    context.user_data[USER_DATA_INJURIES] = user_input
    logger.debug(f"User {update.effective_user.id}: Stored {USER_DATA_INJURIES} = {user_input}")

    keyboard = [
        [InlineKeyboardButton("–ì–∏–ø–µ—Ä—Ç—Ä–æ—Ñ–∏—è", callback_data=HYPERTROPHY)],
        [InlineKeyboardButton("–ü–∞—É—ç—Ä–ª–∏—Ñ—Ç–∏–Ω–≥", callback_data=POWERLIFTING)],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("–ù–∞–∫–æ–Ω–µ—Ü, –∫–∞–∫–æ–≤–∞ –≤–∞—à–∞ –æ—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫?", reply_markup=reply_markup)
    return SELECT_GOAL


async def received_goal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the selected goal, starts plan generation, presents plan and asks for refinement choice."""
    query = update.callback_query
    await query.answer()  # Acknowledge callback
    goal = query.data
    context.user_data[USER_DATA_GOAL] = goal
    logger.info(f"User {update.effective_user.id}: Selected goal {goal}")

    await query.edit_message_text(
        text=f"–û—Ç–ª–∏—á–Ω–æ! –¶–µ–ª—å –≤—ã–±—Ä–∞–Ω–∞: {goal}.\n\n–ì–µ–Ω–µ—Ä–∏—Ä—É—é –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è. üß†"
    )

    # --- Plan Generation --- (Transition happens here implicitly)
    try:
        user_info = context.user_data.copy()  # Get collected data
        plan, history = await openai_service.generate_plan(user_info)

        if plan:
            context.user_data[USER_DATA_PLAN] = plan
            # Initialize history for refinement
            context.user_data[USER_DATA_HISTORY] = history

            await context.bot.send_message(chat_id=update.effective_chat.id, text="–í–æ—Ç –≤–∞—à –Ω–∞—á–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫:")
            # Send plan in chunks if too long (Telegram limit is 4096 chars)
            # Simple chunking for now
            for i in range(0, len(plan), 4000):
                await context.bot.send_message(chat_id=update.effective_chat.id, text=plan[i : i + 4000])

            # Present refinement options
            keyboard = [
                [InlineKeyboardButton("‚ùì –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data=ASK_QUESTION_CALLBACK)],
                [InlineKeyboardButton("‚úèÔ∏è –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data=MODIFY_PLAN_CALLBACK)],
                [InlineKeyboardButton("üèÅ –ó–∞–≤–µ—Ä—à–∏—Ç—å (–û—Ç–º–µ–Ω–∞)", callback_data="cancel_refinement")],  # Option to exit loop
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await context.bot.send_message(
                chat_id=update.effective_chat.id, text="–ß—Ç–æ –±—ã –≤—ã —Ö–æ—Ç–µ–ª–∏ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", reply_markup=reply_markup
            )
            return AWAITING_REFINEMENT_CHOICE  # Go to new state
        else:
            logger.error(f"Plan generation failed for user {update.effective_user.id}")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∞—à–µ–≥–æ –ø–ª–∞–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ, –æ—Ç–ø—Ä–∞–≤–∏–≤ /start.",
            )
            context.user_data.clear()
            return ConversationHandler.END

    except Exception as e:
        logger.exception(f"Exception during plan generation for user {update.effective_user.id}: {e}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start —Å–Ω–æ–≤–∞.",
        )
        context.user_data.clear()
        return ConversationHandler.END


# New handler for refinement choice buttons
async def received_refinement_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the user's choice between asking a question or suggesting modification."""
    query = update.callback_query
    await query.answer()
    choice = query.data

    if choice == ASK_QUESTION_CALLBACK:
        logger.info(f"User {update.effective_user.id} chose to ask a question.")
        context.user_data[USER_DATA_REFINEMENT_TYPE] = "ask"
        await query.edit_message_text(text="–•–æ—Ä–æ—à–æ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –æ –ø–ª–∞–Ω–µ.")
        return AWAITING_REFINEMENT_INPUT
    elif choice == MODIFY_PLAN_CALLBACK:
        logger.info(f"User {update.effective_user.id} chose to suggest modification.")
        context.user_data[USER_DATA_REFINEMENT_TYPE] = "modify"
        await query.edit_message_text(text="–•–æ—Ä–æ—à–æ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å.")
        return AWAITING_REFINEMENT_INPUT
    elif choice == "cancel_refinement":
        logger.info(f"User {update.effective_user.id} chose to finish refinement.")
        await query.edit_message_text(text="–ü–æ–Ω—è—Ç–Ω–æ. –ü–ª–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω! –û—Ç–ø—Ä–∞–≤—å—Ç–µ /start –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ.")
        return ConversationHandler.END
    else:
        logger.warning(f"Received unexpected callback data in refinement choice: {choice}")
        await query.edit_message_text(text="–ò–∑–≤–∏–Ω–∏—Ç–µ, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel.")
        return AWAITING_REFINEMENT_CHOICE


# Renamed from received_refinement_request
async def process_refinement_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles user's text input for refinement/questions after choice."""
    user_request = update.message.text
    user = update.effective_user
    refinement_type = context.user_data.get(USER_DATA_REFINEMENT_TYPE, "unknown")
    logger.info(f"User {user.id} refinement input (type: {refinement_type}): {user_request}")

    if USER_DATA_HISTORY not in context.user_data or not context.user_data[USER_DATA_HISTORY]:
        logger.warning(f"User {user.id} in refinement state but no history found.")
        await update.message.reply_text(
            "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, —É –º–µ–Ω—è –Ω–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start."
        )
        context.user_data.clear()
        return ConversationHandler.END

    history = context.user_data[USER_DATA_HISTORY]
    history.append({"role": "user", "content": user_request})

    await update.message.reply_text("–ü–æ–Ω—è–ª. –û–±–¥—É–º—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å... ü§î")

    try:
        response, new_history = await openai_service.refine_plan(history)

        if response:
            if len(response) > 4096:
                logger.warning("Refinement response exceeds Telegram limit. Sending truncated.")
                response_part = response[:4000] + "... (–æ—Ç–≤–µ—Ç –æ–±—Ä–µ–∑–∞–Ω)"
            else:
                response_part = response

            context.user_data[USER_DATA_HISTORY] = new_history
            await update.message.reply_text(response_part)

            keyboard = [
                [InlineKeyboardButton("‚ùì –ó–∞–¥–∞—Ç—å –µ—â–µ –≤–æ–ø—Ä–æ—Å", callback_data=ASK_QUESTION_CALLBACK)],
                [InlineKeyboardButton("‚úèÔ∏è –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –µ—â–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data=MODIFY_PLAN_CALLBACK)],
                [InlineKeyboardButton("üèÅ –ó–∞–≤–µ—Ä—à–∏—Ç—å (–û—Ç–º–µ–Ω–∞)", callback_data="cancel_refinement")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text("–ß—Ç–æ –±—ã –≤—ã —Ö–æ—Ç–µ–ª–∏ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", reply_markup=reply_markup)
            return AWAITING_REFINEMENT_CHOICE
        else:
            logger.error(f"Plan refinement failed for user {user.id}")
            keyboard = [
                [InlineKeyboardButton("‚ùì –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data=ASK_QUESTION_CALLBACK)],
                [InlineKeyboardButton("‚úèÔ∏è –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data=MODIFY_PLAN_CALLBACK)],
                [InlineKeyboardButton("üèÅ –û—Ç–º–µ–Ω–∞", callback_data="cancel_refinement")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ —Å–º–æ–≥ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —ç—Ç–æ—Ç –∑–∞–ø—Ä–æ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=reply_markup
            )
            return AWAITING_REFINEMENT_CHOICE

    except Exception as e:
        logger.exception(f"Exception during plan refinement for user {user.id}: {e}")
        keyboard = [
            [InlineKeyboardButton("‚ùì –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data=ASK_QUESTION_CALLBACK)],
            [InlineKeyboardButton("‚úèÔ∏è –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data=MODIFY_PLAN_CALLBACK)],
            [InlineKeyboardButton("üèÅ –û—Ç–º–µ–Ω–∞", callback_data="cancel_refinement")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=reply_markup
        )
        return AWAITING_REFINEMENT_CHOICE


async def unknown_state_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles messages received in an unexpected state or with unexpected commands."""
    logger.warning(f"Received unexpected message/command in conversation from user {update.effective_user.id}")
    await update.message.reply_text(
        "–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ –æ–∂–∏–¥–∞–ª —ç—Ç–æ–≥–æ. –ï—Å–ª–∏ –≤—ã –∑–∞—Å—Ç—Ä—è–ª–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /cancel –∏ –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start."
    )


# --- Conversation Handler Definition ---


def create_workflow_handler() -> ConversationHandler:
    """Creates the ConversationHandler for the main workflow."""
    return ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^/start$"), start)],  # Use start from start_handler as entry
        states={
            ASK_AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_age)],
            ASK_HEIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_height)],
            ASK_WEIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_weight)],
            ASK_EXPERIENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_experience)],
            ASK_BENCH: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_bench)],
            ASK_INJURIES: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_injuries)],
            SELECT_GOAL: [CallbackQueryHandler(received_goal)],
            # Note: GENERATING_PLAN is a transient state handled within received_goal
            AWAITING_REFINEMENT_CHOICE: [
                CallbackQueryHandler(
                    received_refinement_choice,
                    pattern=f"^({ASK_QUESTION_CALLBACK}|{MODIFY_PLAN_CALLBACK}|cancel_refinement)$",
                )
            ],
            AWAITING_REFINEMENT_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_refinement_input)],
        },
        fallbacks=[
            MessageHandler(filters.Regex("^/cancel$"), cancel),  # Use cancel from start_handler
            CallbackQueryHandler(cancel, pattern="^cancel_refinement$"),  # Handle cancel button from refinement choice
            MessageHandler(filters.COMMAND, unknown_state_handler),  # Handle unexpected commands
            MessageHandler(filters.ALL, unknown_state_handler),  # Handle unexpected message types
        ],
        per_message=False,  # Process messages based on state, not one handler per message
        # name="plan_workflow", # Optional: Name for debugging
        # persistent=True # Handled by Application builder persistence
    )
